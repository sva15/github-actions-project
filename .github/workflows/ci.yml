name: CI/CD Pipeline with Change Detection

on:
  push:
    branches: [ main ]
  pull_request:
    branches: [ main ]

jobs:
  detect-changes:
    runs-on: ubuntu-latest
    outputs:
      ui-changed: ${{ steps.changes.outputs.ui }}
      any-changes: ${{ steps.changes.outputs.any-changes }}
      changed-subdirs: ${{ steps.changes.outputs.changed-subdirs }}
      changed-services: ${{ steps.changes.outputs.changed-services }}
      changed-agents: ${{ steps.changes.outputs.changed-agents }}
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      with:
        fetch-depth: 2  # Fetch current commit and parent
    
    - name: Detect changed directories
      id: changes
      run: |
        # For pull requests, compare against the target branch
        if [ "${{ github.event_name }}" == "pull_request" ]; then
          BASE_SHA="${{ github.event.pull_request.base.sha }}"
          HEAD_SHA="${{ github.event.pull_request.head.sha }}"
          echo "Comparing PR: $BASE_SHA..$HEAD_SHA"
          CHANGED_FILES=$(git diff --name-only $BASE_SHA..$HEAD_SHA)
        else
          # For push events, compare HEAD with HEAD~1
          echo "Comparing push: HEAD~1..HEAD"
          CHANGED_FILES=$(git diff --name-only HEAD~1..HEAD)
        fi
        
        echo "Changed files:"
        echo "$CHANGED_FILES"
        echo "---"
        
        # Initialize arrays for changed subdirectories
        UI_CHANGED=false
        CHANGED_SUBDIRS=""
        CHANGED_SERVICES=""
        CHANGED_AGENTS=""
        
        # Check each changed file against our target directories
        while IFS= read -r file; do
          if [[ -n "$file" ]]; then
            echo "Checking file: $file"
            
            # Check backend/services/*/*
            if [[ "$file" == backend/services/*/* ]]; then
              # Extract the specific service directory (second level)
              SERVICE_DIR=$(echo "$file" | cut -d'/' -f3)
              FULL_SERVICE_PATH="backend/services/$SERVICE_DIR"
              echo "  -> Service changed: $FULL_SERVICE_PATH"
              
              if [[ "$CHANGED_SUBDIRS" != *"$FULL_SERVICE_PATH"* ]]; then
                CHANGED_SUBDIRS="${CHANGED_SUBDIRS:+$CHANGED_SUBDIRS,}$FULL_SERVICE_PATH"
              fi
              if [[ "$CHANGED_SERVICES" != *"$SERVICE_DIR"* ]]; then
                CHANGED_SERVICES="${CHANGED_SERVICES:+$CHANGED_SERVICES,}$SERVICE_DIR"
              fi
            fi
            
            # Check backend/agents/*/*
            if [[ "$file" == backend/agents/*/* ]]; then
              # Extract the specific agent directory (second level)
              AGENT_DIR=$(echo "$file" | cut -d'/' -f3)
              FULL_AGENT_PATH="backend/agents/$AGENT_DIR"
              echo "  -> Agent changed: $FULL_AGENT_PATH"
              
              if [[ "$CHANGED_SUBDIRS" != *"$FULL_AGENT_PATH"* ]]; then
                CHANGED_SUBDIRS="${CHANGED_SUBDIRS:+$CHANGED_SUBDIRS,}$FULL_AGENT_PATH"
              fi
              if [[ "$CHANGED_AGENTS" != *"$AGENT_DIR"* ]]; then
                CHANGED_AGENTS="${CHANGED_AGENTS:+$CHANGED_AGENTS,}$AGENT_DIR"
              fi
            fi
            
            # Check ui/
            if [[ "$file" == ui/* ]]; then
              echo "  -> UI changed"
              UI_CHANGED=true
              if [[ "$CHANGED_SUBDIRS" != *"ui"* ]]; then
                CHANGED_SUBDIRS="${CHANGED_SUBDIRS:+$CHANGED_SUBDIRS,}ui"
              fi
            fi
          fi
        done <<< "$CHANGED_FILES"
        
        # Determine if any relevant changes occurred
        ANY_CHANGES=false
        if [[ -n "$CHANGED_SERVICES" || -n "$CHANGED_AGENTS" || "$UI_CHANGED" == "true" ]]; then
          ANY_CHANGES=true
        fi
        
        # Output results
        echo "Results:"
        echo "  UI Changed: $UI_CHANGED"
        echo "  Any Changes: $ANY_CHANGES"
        echo "  Changed Subdirectories: $CHANGED_SUBDIRS"
        echo "  Changed Services: $CHANGED_SERVICES"
        echo "  Changed Agents: $CHANGED_AGENTS"
        
        # Set outputs for other jobs
        echo "ui=$UI_CHANGED" >> $GITHUB_OUTPUT
        echo "any-changes=$ANY_CHANGES" >> $GITHUB_OUTPUT
        echo "changed-subdirs=$CHANGED_SUBDIRS" >> $GITHUB_OUTPUT
        echo "changed-services=$CHANGED_SERVICES" >> $GITHUB_OUTPUT
        echo "changed-agents=$CHANGED_AGENTS" >> $GITHUB_OUTPUT

  # Generate matrix for changed backend components
  prepare-backend-matrix:
    needs: detect-changes
    runs-on: ubuntu-latest
    if: needs.detect-changes.outputs.changed-services != '' || needs.detect-changes.outputs.changed-agents != ''
    outputs:
      matrix: ${{ steps.set-matrix.outputs.matrix }}
      has-changes: ${{ steps.set-matrix.outputs.has-changes }}
    
    steps:
    - name: Generate test matrix
      id: set-matrix
      run: |
        MATRIX_DIRS=""
        HAS_CHANGES=false
        
        # Add changed services to matrix
        if [[ -n "${{ needs.detect-changes.outputs.changed-services }}" ]]; then
          IFS=',' read -ra SERVICES <<< "${{ needs.detect-changes.outputs.changed-services }}"
          for service in "${SERVICES[@]}"; do
            if [[ -n "$service" ]]; then
              MATRIX_DIRS="${MATRIX_DIRS:+$MATRIX_DIRS,}\"backend/services/$service\""
              HAS_CHANGES=true
            fi
          done
        fi
        
        # Add changed agents to matrix
        if [[ -n "${{ needs.detect-changes.outputs.changed-agents }}" ]]; then
          IFS=',' read -ra AGENTS <<< "${{ needs.detect-changes.outputs.changed-agents }}"
          for agent in "${AGENTS[@]}"; do
            if [[ -n "$agent" ]]; then
              MATRIX_DIRS="${MATRIX_DIRS:+$MATRIX_DIRS,}\"backend/agents/$agent\""
              HAS_CHANGES=true
            fi
          done
        fi
        
        # Create JSON matrix
        if [[ "$HAS_CHANGES" == "true" ]]; then
          MATRIX_JSON="{\"directory\":[$MATRIX_DIRS]}"
          echo "Generated matrix: $MATRIX_JSON"
        else
          MATRIX_JSON="{\"directory\":[]}"
        fi
        
        echo "matrix=$MATRIX_JSON" >> $GITHUB_OUTPUT
        echo "has-changes=$HAS_CHANGES" >> $GITHUB_OUTPUT

  # Test backend components using matrix strategy
  backend-quality-tests:
    needs: [detect-changes, prepare-backend-matrix]
    runs-on: ubuntu-latest
    if: needs.prepare-backend-matrix.outputs.has-changes == 'true'
    strategy:
      matrix: ${{ fromJson(needs.prepare-backend-matrix.outputs.matrix) }}
      fail-fast: false  # Continue testing other dirs even if one fails
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
    
    - name: Set up Python
      uses: actions/setup-python@v4
      with:
        python-version: '3.11'
    
    - name: Install dependencies
      run: |
        echo "Installing dependencies for ${{ matrix.directory }}"
        python -m pip install --upgrade pip
        
        # Install common dependencies
        if [ -f requirements.txt ]; then
          pip install -r requirements.txt
        fi
        
        # Install directory-specific dependencies if they exist
        if [ -f "${{ matrix.directory }}/requirements.txt" ]; then
          pip install -r "${{ matrix.directory }}/requirements.txt"
        fi
        
        # Install testing dependencies
        pip install pytest pytest-cov flake8 black isort mypy
    
    - name: Code quality checks
      run: |
        echo "Running code quality checks for ${{ matrix.directory }}"
        
        # Format check with black
        echo "Checking code formatting..."
        if black --check "${{ matrix.directory }}" 2>&1; then
          BLACK_STATUS="PASSED"
        else
          BLACK_STATUS="FAILED"
        fi
        
        # Import sorting check
        echo "Checking import sorting..."
        if isort --check-only "${{ matrix.directory }}" 2>&1; then
          ISORT_STATUS="PASSED"
        else
          ISORT_STATUS="FAILED"
        fi
        
        # Linting with flake8
        echo "Running linter..."
        if flake8 "${{ matrix.directory }}" --format='%(path)s:%(row)d:%(col)d: %(code)s %(text)s' 2>&1; then
          FLAKE8_STATUS="PASSED"
        else
          FLAKE8_STATUS="FAILED"
        fi
        
        # Type checking with mypy
        echo "Running type checker..."
        if mypy "${{ matrix.directory }}" 2>&1; then
          MYPY_STATUS="PASSED"
        else
          MYPY_STATUS="FAILED"
        fi
        
        # Store results for summary
        echo "BLACK_STATUS=$BLACK_STATUS" >> $GITHUB_ENV
        echo "ISORT_STATUS=$ISORT_STATUS" >> $GITHUB_ENV
        echo "FLAKE8_STATUS=$FLAKE8_STATUS" >> $GITHUB_ENV
        echo "MYPY_STATUS=$MYPY_STATUS" >> $GITHUB_ENV
    
    - name: Run tests
      run: |
        echo "Running tests for ${{ matrix.directory }}"
        
        # Run pytest with coverage
        if [ -d "${{ matrix.directory }}/tests" ]; then
          if pytest "${{ matrix.directory }}/tests" \
            --cov="${{ matrix.directory }}" \
            --cov-branch \
            --cov-report=xml:coverage-${{ matrix.directory }}.xml \
            --cov-report=term-missing \
            -v 2>&1; then
            TEST_STATUS="PASSED"
          else
            TEST_STATUS="FAILED"
          fi
        else
          if find "${{ matrix.directory }}" -name "test_*.py" -o -name "*_test.py" | grep -q .; then
            if pytest "${{ matrix.directory }}" \
              --cov="${{ matrix.directory }}" \
              --cov-branch \
              --cov-report=xml:coverage-${{ matrix.directory }}.xml \
              --cov-report=term-missing \
              -v 2>&1; then
              TEST_STATUS="PASSED"
            else
              TEST_STATUS="FAILED"
            fi
          else
            TEST_STATUS="NO_TESTS"
          fi
        fi
        
        # Store test status for summary
        echo "TEST_STATUS=$TEST_STATUS" >> $GITHUB_ENV
        
    - name: Generate summary report
      if: always()
      run: |
        # Parse coverage from XML
        if [ -f "coverage-${{ matrix.directory }}.xml" ]; then
          COVERAGE=$(python3 -c "
        import xml.etree.ElementTree as ET
        try:
            tree = ET.parse('coverage-${{ matrix.directory }}.xml')
            root = tree.getroot()
            coverage = root.attrib.get('line-rate', '0')
            percentage = float(coverage) * 100
            print(f'{percentage:.1f}')
        except:
            print('0.0')
        ")
        else
          COVERAGE="N/A"
        fi
        
        # Validate coverage > 90
        if [ "$COVERAGE" != "N/A" ]; then
          COVERAGE_NUM=$(echo "$COVERAGE" | awk '{print ($0+0)}')
          if (( $(echo "$COVERAGE_NUM > 90" | bc -l) )); then
            COVERAGE_STATUS="PASSED ($COVERAGE%)"
          else
            COVERAGE_STATUS="FAILED ($COVERAGE%)"
          fi
        else
          COVERAGE_STATUS="N/A"
        fi
        
        # Generate professional summary tables
        echo "## Test Results: \`${{ matrix.directory }}\`" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "| Check | Status |" >> $GITHUB_STEP_SUMMARY
        echo "|-------|--------|" >> $GITHUB_STEP_SUMMARY
        echo "| Code Formatting | $BLACK_STATUS |" >> $GITHUB_STEP_SUMMARY
        echo "| Import Sorting | $ISORT_STATUS |" >> $GITHUB_STEP_SUMMARY
        echo "| Linting | $FLAKE8_STATUS |" >> $GITHUB_STEP_SUMMARY
        echo "| Type Checking | $MYPY_STATUS |" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "| Unit Tests | Status | Coverage |" >> $GITHUB_STEP_SUMMARY
        echo "|-----------|--------|----------|" >> $GITHUB_STEP_SUMMARY
        echo "| Unit Tests | $TEST_STATUS | $COVERAGE_STATUS |" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
    

  ui-job:
    needs: detect-changes
    runs-on: ubuntu-latest
    if: needs.detect-changes.outputs.ui-changed == 'true'
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
    
    - name: Setup Node.js
      uses: actions/setup-node@v4
      with:
        node-version: '18'
        cache: 'npm'
        cache-dependency-path: 'ui/package-lock.json'
    
    - name: Install dependencies
      run: |
        cd ui
        npm ci
    
    - name: Code quality checks
      run: |
        cd ui
        echo "Running code quality checks for UI"
        
        # ESLint check
        echo "Running ESLint..."
        if npm run lint 2>&1; then
          ESLINT_STATUS="PASSED"
        else
          ESLINT_STATUS="FAILED"
        fi
        
        # Prettier check
        echo "Checking code formatting with Prettier..."
        if npm run format:check 2>&1; then
          PRETTIER_STATUS="PASSED"
        else
          PRETTIER_STATUS="FAILED"
        fi
        
        # TypeScript check (if applicable)
        echo "Running TypeScript check..."
        if npm run type-check 2>&1; then
          TYPESCRIPT_STATUS="PASSED"
        else
          TYPESCRIPT_STATUS="FAILED"
        fi
        
        # Store quality check results
        echo "ESLINT_STATUS=$ESLINT_STATUS" >> $GITHUB_ENV
        echo "PRETTIER_STATUS=$PRETTIER_STATUS" >> $GITHUB_ENV
        echo "TYPESCRIPT_STATUS=$TYPESCRIPT_STATUS" >> $GITHUB_ENV
    
    - name: Run tests
      run: |
        cd ui
        echo "Running tests for UI"
        
        # Run tests with coverage
        if npm test -- --coverage --watchAll=false --coverageReporters=text-lcov,xml 2>&1; then
          TEST_STATUS="PASSED"
        else
          TEST_STATUS="FAILED"
        fi
        
        # Store test status
        echo "TEST_STATUS=$TEST_STATUS" >> $GITHUB_ENV
    
    - name: Generate summary report
      if: always()
      run: |
        cd ui
        
        # Parse coverage from coverage-summary.json or lcov.info
        if [ -f "coverage/coverage-summary.json" ]; then
          COVERAGE=$(node -e "
            const fs = require('fs');
            try {
              const summary = JSON.parse(fs.readFileSync('coverage/coverage-summary.json', 'utf8'));
              const linesCoverage = summary.total.lines.pct;
              console.log(linesCoverage.toFixed(1));
            } catch (e) {
              console.log('0.0');
            }
          ")
        else
          COVERAGE="N/A"
        fi
        
        # Validate coverage > 90
        if [ "$COVERAGE" != "N/A" ]; then
          COVERAGE_NUM=$(echo "$COVERAGE" | awk '{print ($0+0)}')
          if (( $(echo "$COVERAGE_NUM > 90" | bc -l) )); then
            COVERAGE_STATUS="PASSED ($COVERAGE%)"
          else
            COVERAGE_STATUS="FAILED ($COVERAGE%)"
          fi
        else
          COVERAGE_STATUS="N/A"
        fi
        
        # Generate professional summary tables
        echo "## Test Results: \`ui\`" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "| Check | Status |" >> $GITHUB_STEP_SUMMARY
        echo "|-------|--------|" >> $GITHUB_STEP_SUMMARY
        echo "| ESLint | $ESLINT_STATUS |" >> $GITHUB_STEP_SUMMARY
        echo "| Code Formatting | $PRETTIER_STATUS |" >> $GITHUB_STEP_SUMMARY
        echo "| Type Checking | $TYPESCRIPT_STATUS |" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "| Unit Tests | Status | Coverage |" >> $GITHUB_STEP_SUMMARY
        echo "|-----------|--------|----------|" >> $GITHUB_STEP_SUMMARY
        echo "| Unit Tests | $TEST_STATUS | $COVERAGE_STATUS |" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
    

  sonarqube-scan-backend:
    name: SonarQube Scan - Backend
    needs: [detect-changes, prepare-backend-matrix]
    if: |
      needs.prepare-backend-matrix.outputs.has-changes == 'true' &&
      (github.ref == 'refs/heads/main' ||
       (github.event_name == 'pull_request' && github.base_ref == 'main'))
    runs-on: ubuntu-latest
    strategy:
      matrix:
        directory: ${{ fromJson(needs.prepare-backend-matrix.outputs.matrix).directory }}
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0
      - name: SonarQube Scan
        uses: SonarSource/sonarqube-scan-action@v5.3.0
        with:
          projectBaseDir: ${{ matrix.directory }}
        env:
          SONAR_TOKEN: ${{ secrets.SONAR_TOKEN }}
      
      - name: SonarQube Quality Gate check
        id: sonarqube-quality-gate-check
        uses: sonarsource/sonarqube-quality-gate-action@master
        with:
          pollingTimeoutSec: 600
          scanMetadataReportFile: ${{ matrix.directory }}/.scannerwork/report-task.txt
        env:
          SONAR_TOKEN: ${{ secrets.SONAR_TOKEN }}
      
      - name: Show SonarQube Quality Gate Status
        run: |
          QG_STATUS="${{ steps.sonarqube-quality-gate-check.outputs.quality-gate-status }}"
          echo "## SonarQube Quality Gate: \`${{ matrix.directory }}\`" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "| Component | Quality Gate Status |" >> $GITHUB_STEP_SUMMARY
          echo "|-----------|---------------------|" >> $GITHUB_STEP_SUMMARY
          echo "| ${{ matrix.directory }} | $QG_STATUS |" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY

  sonarqube-scan-ui:
    name: SonarQube Scan - UI
    needs: [detect-changes, ui-job]
    if: |
      needs.detect-changes.outputs.ui-changed == 'true' &&
      (github.ref == 'refs/heads/main' ||
       (github.event_name == 'pull_request' && github.base_ref == 'main'))
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0
      - name: SonarQube Scan
        uses: SonarSource/sonarqube-scan-action@v5.3.0
        with:
          projectBaseDir: ui
        env:
          SONAR_TOKEN: ${{ secrets.SONAR_TOKEN }}
      
      - name: SonarQube Quality Gate check
        id: sonarqube-quality-gate-check-ui
        uses: sonarsource/sonarqube-quality-gate-action@master
        with:
          pollingTimeoutSec: 600
          scanMetadataReportFile: ui/.scannerwork/report-task.txt
        env:
          SONAR_TOKEN: ${{ secrets.SONAR_TOKEN }}
      
      - name: Show SonarQube Quality Gate Status
        run: |
          QG_STATUS="${{ steps.sonarqube-quality-gate-check-ui.outputs.quality-gate-status }}"
          echo "## SonarQube Quality Gate: \`ui\`" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "| Component | Quality Gate Status |" >> $GITHUB_STEP_SUMMARY
          echo "|-----------|---------------------|" >> $GITHUB_STEP_SUMMARY
          echo "| ui | $QG_STATUS |" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY

  # Job that runs when no relevant changes are detected
  no-changes-job:
    needs: detect-changes
    runs-on: ubuntu-latest
    if: needs.detect-changes.outputs.any-changes == 'false'
    
    steps:
    - name: No relevant changes
      run: |
        echo "No changes detected in monitored directories (backend/services, backend/agents, ui)"
        echo "Skipping pipeline execution"
