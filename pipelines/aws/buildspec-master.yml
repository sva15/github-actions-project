# AWS CodeBuild Master Pipeline
# Single buildspec that dynamically detects and deploys changed services
# Uses aws-services-config.yml for service definitions and configurations

version: 0.2

env:
  variables:
    AWS_DEFAULT_REGION: "us-east-1"
    PYTHON_VERSION: "3.9"
    NODE_VERSION: "18"
  parameter-store:
    ACCOUNT_ID: "/mono-repo/aws-account-id"
    DEPLOYMENT_BUCKET: "/mono-repo/deployment-bucket"
    LAMBDA_EXECUTION_ROLE_ARN: "/mono-repo/lambda-execution-role-arn"
    EC2_KEY_PAIR: "/mono-repo/ec2-key-pair"
    SLACK_WEBHOOK_URL: "/mono-repo/slack/webhook-url"

phases:
  install:
    runtime-versions:
      python: 3.9
      nodejs: 18
      docker: 20
    commands:
      - echo "üîß Installing dependencies..."
      
      # Install yq for YAML parsing
      - wget -qO /usr/local/bin/yq https://github.com/mikefarah/yq/releases/latest/download/yq_linux_amd64
      - chmod +x /usr/local/bin/yq
      
      # Install jq for JSON parsing
      - apt-get update && apt-get install -y jq zip unzip
      
      # Install AWS CLI v2 (if not already installed)
      - |
        if ! command -v aws &> /dev/null; then
          curl "https://awscli.amazonaws.com/awscli-exe-linux-x86_64.zip" -o "awscliv2.zip"
          unzip awscliv2.zip
          ./aws/install
        fi
      
      # Configure Docker for ECR
      - aws ecr get-login-password --region $AWS_DEFAULT_REGION | docker login --username AWS --password-stdin $ACCOUNT_ID.dkr.ecr.$AWS_DEFAULT_REGION.amazonaws.com
      
      - echo "‚úÖ Dependencies installed successfully"

  pre_build:
    commands:
      - echo "üîç Detecting changed services and determining environment..."
      
      # Determine environment from branch or CodeBuild environment
      - |
        if [ ! -z "$CODEBUILD_WEBHOOK_HEAD_REF" ]; then
          BRANCH_NAME=$(echo $CODEBUILD_WEBHOOK_HEAD_REF | sed 's/refs\/heads\///')
        else
          BRANCH_NAME=${CODEBUILD_SOURCE_VERSION:-main}
        fi
        
        echo "Branch: $BRANCH_NAME"
        
        case $BRANCH_NAME in
          "main")
            ENV="prod"
            ;;
          "develop")
            ENV="staging"
            ;;
          "feature/"*)
            ENV="dev"
            ;;
          "hotfix/"*)
            ENV="hotfix"
            ;;
          *)
            ENV="dev"
            ;;
        esac
        
        echo "Environment: $ENV"
        echo "$ENV" > /tmp/environment
        echo "DEPLOYMENT_ENV=$ENV" >> /tmp/deployment_status
      
      # Get changed files and detect services
      - |
        echo "Detecting changed services..."
        
        # Get changed files (for webhook triggers)
        if [ ! -z "$CODEBUILD_WEBHOOK_PREV_COMMIT" ]; then
          CHANGED_FILES=$(git diff --name-only $CODEBUILD_WEBHOOK_PREV_COMMIT HEAD 2>/dev/null || echo "")
        else
          # Fallback for manual triggers or initial commit
          CHANGED_FILES=$(git ls-files)
        fi
        
        echo "Changed files:"
        echo "$CHANGED_FILES"
        
        # Parse services config and detect changes
        CHANGED_SERVICES=""
        
        # Get all services from config
        SERVICES=$(yq eval '.services | keys | .[]' aws-services-config.yml)
        
        for SERVICE in $SERVICES; do
          SERVICE_PATH=$(yq eval ".services.$SERVICE.path" aws-services-config.yml)
          
          if echo "$CHANGED_FILES" | grep -q "$SERVICE_PATH/"; then
            CHANGED_SERVICES="$CHANGED_SERVICES $SERVICE"
            echo "‚úÖ Service changed: $SERVICE (path: $SERVICE_PATH)"
          fi
        done
        
        if [ -z "$CHANGED_SERVICES" ]; then
          echo "‚ÑπÔ∏è No services changed, skipping deployment"
          echo "SKIP_DEPLOYMENT=true" >> /tmp/deployment_status
          echo "" > /tmp/changed_services
        else
          echo "üöÄ Services to deploy: $CHANGED_SERVICES"
          echo "$CHANGED_SERVICES" > /tmp/changed_services
          echo "SKIP_DEPLOYMENT=false" >> /tmp/deployment_status
        fi

  build:
    commands:
      - echo "üèóÔ∏è Building and deploying services..."
      - source /tmp/deployment_status
      
      - |
        if [ "$SKIP_DEPLOYMENT" = "true" ]; then
          echo "‚è≠Ô∏è Skipping deployment - no changes detected"
          exit 0
        fi
        
        CHANGED_SERVICES=$(cat /tmp/changed_services)
        ENV=$(cat /tmp/environment)
        
        echo "üöÄ Starting deployment for environment: $ENV"
        echo "üì¶ Services to deploy: $CHANGED_SERVICES"
        
        # Deploy each changed service
        for SERVICE in $CHANGED_SERVICES; do
          echo "üîß Processing service: $SERVICE"
          
          SERVICE_TYPE=$(yq eval ".services.$SERVICE.type" aws-services-config.yml)
          SERVICE_PATH=$(yq eval ".services.$SERVICE.path" aws-services-config.yml)
          
          case $SERVICE_TYPE in
            "lambda")
              echo "‚òÅÔ∏è Deploying Lambda Function: $SERVICE"
              
              # Get service configuration from config file
              RUNTIME=$(yq eval ".services.$SERVICE.runtime" aws-services-config.yml)
              MEMORY=$(yq eval ".services.$SERVICE.memory" aws-services-config.yml)
              TIMEOUT=$(yq eval ".services.$SERVICE.timeout" aws-services-config.yml)
              HANDLER=$(yq eval ".services.$SERVICE.handler" aws-services-config.yml)
              ARCHITECTURE=$(yq eval ".services.$SERVICE.architecture" aws-services-config.yml)
              DESCRIPTION=$(yq eval ".services.$SERVICE.description" aws-services-config.yml)
              
              # Get environment-specific overrides
              ENV_MEMORY=$(yq eval ".environments.$ENV.overrides.$SERVICE.memory // $MEMORY" aws-services-config.yml)
              ENV_TIMEOUT=$(yq eval ".environments.$ENV.overrides.$SERVICE.timeout // $TIMEOUT" aws-services-config.yml)
              RESERVED_CONCURRENCY=$(yq eval ".environments.$ENV.overrides.$SERVICE.reserved_concurrency // .services.$SERVICE.config.reserved_concurrency" aws-services-config.yml)
              PROVISIONED_CONCURRENCY=$(yq eval ".environments.$ENV.overrides.$SERVICE.provisioned_concurrency // .services.$SERVICE.config.provisioned_concurrency" aws-services-config.yml)
              
              FUNCTION_NAME="$ENV-$SERVICE"
              
              echo "Function: $FUNCTION_NAME"
              echo "Runtime: $RUNTIME"
              echo "Memory: $ENV_MEMORY MB"
              echo "Timeout: $ENV_TIMEOUT seconds"
              echo "Architecture: $ARCHITECTURE"
              echo "Handler: $HANDLER"
              echo "Reserved Concurrency: $RESERVED_CONCURRENCY"
              echo "Provisioned Concurrency: $PROVISIONED_CONCURRENCY"
              
              # Build environment variables from config
              ENV_VARS="{\"ENVIRONMENT\":\"$ENV\",\"LOG_LEVEL\":\"INFO\""
              
              # Get environment variables from config
              ENV_VAR_COUNT=$(yq eval ".services.$SERVICE.env_vars | length" aws-services-config.yml)
              if [ "$ENV_VAR_COUNT" != "0" ] && [ "$ENV_VAR_COUNT" != "null" ]; then
                for ((i=0; i<$ENV_VAR_COUNT; i++)); do
                  VAR_NAME=$(yq eval ".services.$SERVICE.env_vars[$i].name" aws-services-config.yml)
                  VAR_DEFAULT=$(yq eval ".services.$SERVICE.env_vars[$i].default" aws-services-config.yml)
                  
                  if [ "$VAR_DEFAULT" != "null" ]; then
                    ENV_VARS="$ENV_VARS,\"$VAR_NAME\":\"$VAR_DEFAULT\""
                  else
                    # For variables without defaults, set placeholder that can be updated later
                    ENV_VARS="$ENV_VARS,\"$VAR_NAME\":\"PLACEHOLDER_$VAR_NAME\""
                  fi
                done
              fi
              
              ENV_VARS="$ENV_VARS}"
              echo "Environment Variables: $ENV_VARS"
              
              # Package function
              cd $SERVICE_PATH
              
              # Install dependencies
              if [ -f "requirements.txt" ]; then
                echo "Installing Python dependencies..."
                pip install -r requirements.txt -t .
              fi
              
              # Create ZIP package
              zip -r /tmp/${FUNCTION_NAME}.zip . -x "*.pyc" "__pycache__/*" "test_*" "*.md"
              
              cd - > /dev/null
              
              # Upload to S3
              S3_KEY="lambda-deployments/$ENV/$SERVICE/$CODEBUILD_BUILD_ID.zip"
              aws s3 cp /tmp/${FUNCTION_NAME}.zip s3://$DEPLOYMENT_BUCKET/$S3_KEY
              
              # Check if function exists
              if aws lambda get-function --function-name $FUNCTION_NAME > /dev/null 2>&1; then
                echo "Updating existing function..."
                aws lambda update-function-code \
                  --function-name $FUNCTION_NAME \
                  --s3-bucket $DEPLOYMENT_BUCKET \
                  --s3-key $S3_KEY
                # Update function configuration with all parameters
                aws lambda update-function-configuration \
                  --function-name $FUNCTION_NAME \
                  --memory-size $ENV_MEMORY \
                  --timeout $ENV_TIMEOUT \
                  --environment Variables="$ENV_VARS" \
                  --description "$DESCRIPTION" \
                  --handler $HANDLER
                
                # Set reserved concurrency if specified
                if [ "$RESERVED_CONCURRENCY" != "null" ] && [ "$RESERVED_CONCURRENCY" -gt 0 ]; then
                  aws lambda put-reserved-concurrency-config \
                    --function-name $FUNCTION_NAME \
                    --reserved-concurrent-executions $RESERVED_CONCURRENCY
                fi
                
                # Set provisioned concurrency if specified
                if [ "$PROVISIONED_CONCURRENCY" != "null" ] && [ "$PROVISIONED_CONCURRENCY" -gt 0 ]; then
                  # First publish a version
                  VERSION=$(aws lambda publish-version \
                    --function-name $FUNCTION_NAME \
                    --query 'Version' --output text)
                  
                  # Then set provisioned concurrency
                  aws lambda put-provisioned-concurrency-config \
                    --function-name $FUNCTION_NAME \
                    --qualifier $VERSION \
                    --provisioned-concurrent-executions $PROVISIONED_CONCURRENCY
                fi
              else
                echo "Creating new function..."
                aws lambda create-function \
                  --function-name $FUNCTION_NAME \
                  --runtime $RUNTIME \
                  --role $LAMBDA_EXECUTION_ROLE_ARN \
                  --handler $HANDLER \
                  --code S3Bucket=$DEPLOYMENT_BUCKET,S3Key=$S3_KEY \
                  --memory-size $ENV_MEMORY \
                  --timeout $ENV_TIMEOUT \
                  --environment Variables="$ENV_VARS" \
                  --description "$DESCRIPTION" \
                  --architectures $ARCHITECTURE
                
                # Set reserved concurrency if specified
                if [ "$RESERVED_CONCURRENCY" != "null" ] && [ "$RESERVED_CONCURRENCY" -gt 0 ]; then
                  aws lambda put-reserved-concurrency-config \
                    --function-name $FUNCTION_NAME \
                    --reserved-concurrent-executions $RESERVED_CONCURRENCY
                fi
                
                # Set provisioned concurrency if specified
                if [ "$PROVISIONED_CONCURRENCY" != "null" ] && [ "$PROVISIONED_CONCURRENCY" -gt 0 ]; then
                  # First publish a version
                  VERSION=$(aws lambda publish-version \
                    --function-name $FUNCTION_NAME \
                    --query 'Version' --output text)
                  
                  # Then set provisioned concurrency
                  aws lambda put-provisioned-concurrency-config \
                    --function-name $FUNCTION_NAME \
                    --qualifier $VERSION \
                    --provisioned-concurrent-executions $PROVISIONED_CONCURRENCY
                fi \
                  --description "Deployed from mono-repo pipeline"
              fi
              
              # Get function URL (if it has one)
              FUNCTION_URL=$(aws lambda get-function-url-config --function-name $FUNCTION_NAME --query 'FunctionUrl' --output text 2>/dev/null || echo "")
              if [ -z "$FUNCTION_URL" ]; then
                # Create function URL if it doesn't exist
                FUNCTION_URL=$(aws lambda create-function-url-config \
                  --function-name $FUNCTION_NAME \
                  --auth-type NONE \
                  --cors AllowMethods=["*"],AllowOrigins=["*"] \
                  --query 'FunctionUrl' --output text)
              fi
              
              echo "‚úÖ Lambda Function deployed successfully: $FUNCTION_NAME"
              echo "üîó Function URL: $FUNCTION_URL"
              echo "$SERVICE=$FUNCTION_URL" >> /tmp/service_urls
              ;;
              
            "ec2")
              echo "üñ•Ô∏è Deploying EC2 Application: $SERVICE"
              
              # Get service configuration from config file
              INSTANCE_TYPE=$(yq eval ".services.$SERVICE.ec2.instance_type" aws-services-config.yml)
              AMI_ID=$(yq eval ".services.$SERVICE.ec2.ami_id" aws-services-config.yml)
              KEY_PAIR=$(yq eval ".services.$SERVICE.ec2.key_pair" aws-services-config.yml)
              SECURITY_GROUPS=$(yq eval ".services.$SERVICE.ec2.security_groups[]" aws-services-config.yml | tr '\n' ' ')
              DESCRIPTION=$(yq eval ".services.$SERVICE.description" aws-services-config.yml)
              
              # Get environment-specific overrides
              ENV_INSTANCE_TYPE=$(yq eval ".environments.$ENV.overrides.$SERVICE.instance_type // $INSTANCE_TYPE" aws-services-config.yml)
              MIN_CAPACITY=$(yq eval ".environments.$ENV.overrides.$SERVICE.min_capacity // .services.$SERVICE.ec2.min_capacity" aws-services-config.yml)
              MAX_CAPACITY=$(yq eval ".environments.$ENV.overrides.$SERVICE.max_capacity // .services.$SERVICE.ec2.max_capacity" aws-services-config.yml)
              DESIRED_CAPACITY=$(yq eval ".environments.$ENV.overrides.$SERVICE.desired_capacity // .services.$SERVICE.ec2.desired_capacity" aws-services-config.yml)
              
              echo "Service: $SERVICE"
              echo "Instance Type: $ENV_INSTANCE_TYPE"
              echo "AMI ID: $AMI_ID"
              echo "Key Pair: $KEY_PAIR"
              echo "Security Groups: $SECURITY_GROUPS"
              echo "Min Capacity: $MIN_CAPACITY"
              echo "Max Capacity: $MAX_CAPACITY"
              echo "Desired Capacity: $DESIRED_CAPACITY"
              
              # Build environment variables for EC2 from config
              EC2_ENV_VARS="ENVIRONMENT=$ENV,LOG_LEVEL=INFO"
              
              # Get environment variables from config
              ENV_VAR_COUNT=$(yq eval ".services.$SERVICE.env_vars | length" aws-services-config.yml)
              if [ "$ENV_VAR_COUNT" != "0" ] && [ "$ENV_VAR_COUNT" != "null" ]; then
                for ((i=0; i<$ENV_VAR_COUNT; i++)); do
                  VAR_NAME=$(yq eval ".services.$SERVICE.env_vars[$i].name" aws-services-config.yml)
                  VAR_DEFAULT=$(yq eval ".services.$SERVICE.env_vars[$i].default" aws-services-config.yml)
                  
                  if [ "$VAR_DEFAULT" != "null" ]; then
                    EC2_ENV_VARS="$EC2_ENV_VARS,$VAR_NAME=$VAR_DEFAULT"
                  else
                    # For variables without defaults, set placeholder
                    EC2_ENV_VARS="$EC2_ENV_VARS,$VAR_NAME=PLACEHOLDER_$VAR_NAME"
                  fi
                done
              fi
              
              echo "Environment Variables: $EC2_ENV_VARS"
              
              # Build and push Docker image
              FULL_IMAGE_NAME="$ENV-$(echo $SERVICE | tr '_' '-')"
              ECR_REPOSITORY="$ACCOUNT_ID.dkr.ecr.$AWS_DEFAULT_REGION.amazonaws.com/mono-repo-$FULL_IMAGE_NAME"
              
              echo "Image Name: $FULL_IMAGE_NAME"
              echo "ECR Repository: $ECR_REPOSITORY"
              echo "Instance Type: $ENV_INSTANCE_TYPE"
              echo "ECR Repository: $ECR_REPOSITORY"
              echo "Min/Max/Desired Capacity: $MIN_CAPACITY/$MAX_CAPACITY/$DESIRED_CAPACITY"
              
              # Create ECR repository if it doesn't exist
              aws ecr describe-repositories --repository-names mono-repo-$FULL_IMAGE_NAME > /dev/null 2>&1 || \
                aws ecr create-repository --repository-name mono-repo-$FULL_IMAGE_NAME
              
              # Build Docker image
              echo "üê≥ Building Docker image..."
              cd $SERVICE_PATH
              docker build -t $FULL_IMAGE_NAME:$CODEBUILD_BUILD_ID -f $DOCKERFILE .
              docker tag $FULL_IMAGE_NAME:$CODEBUILD_BUILD_ID $ECR_REPOSITORY:$CODEBUILD_BUILD_ID
              docker tag $FULL_IMAGE_NAME:$CODEBUILD_BUILD_ID $ECR_REPOSITORY:latest
              
              # Push to ECR
              echo "üì§ Pushing image to ECR..."
              docker push $ECR_REPOSITORY:$CODEBUILD_BUILD_ID
              docker push $ECR_REPOSITORY:latest
              
              cd - > /dev/null
              
              # Create deployment package for CodeDeploy
              mkdir -p /tmp/codedeploy-$SERVICE
              
              # Create appspec.yml for CodeDeploy
              cat > /tmp/codedeploy-$SERVICE/appspec.yml << EOF
        version: 0.0
        os: linux
        files:
          - source: /
            destination: /opt/mono-repo-$FULL_IMAGE_NAME
        hooks:
          BeforeInstall:
            - location: scripts/before_install.sh
              timeout: 300
              runas: root
          ApplicationStart:
            - location: scripts/application_start.sh
              timeout: 300
              runas: root
          ApplicationStop:
            - location: scripts/application_stop.sh
              timeout: 300
              runas: root
          ValidateService:
            - location: scripts/validate_service.sh
              timeout: 300
              runas: root
        EOF
              
              # Create deployment scripts
              mkdir -p /tmp/codedeploy-$SERVICE/scripts
              
              # Before install script
              cat > /tmp/codedeploy-$SERVICE/scripts/before_install.sh << 'EOF'
        #!/bin/bash
        yum update -y
        yum install -y docker
        service docker start
        usermod -a -G docker ec2-user
        
        # Install AWS CLI if not present
        if ! command -v aws &> /dev/null; then
          curl "https://awscli.amazonaws.com/awscli-exe-linux-x86_64.zip" -o "awscliv2.zip"
          unzip awscliv2.zip
          ./aws/install
        fi
        EOF
              
              # Get container port from config
              CONTAINER_PORT=$(yq eval ".services.$SERVICE.container.port // 80" aws-services-config.yml)
              
              # Application start script with all environment variables
              cat > /tmp/codedeploy-$SERVICE/scripts/application_start.sh << EOF
        #!/bin/bash
        cd /opt/mono-repo-$FULL_IMAGE_NAME
        
        # Login to ECR
        aws ecr get-login-password --region $AWS_DEFAULT_REGION | docker login --username AWS --password-stdin $ACCOUNT_ID.dkr.ecr.$AWS_DEFAULT_REGION.amazonaws.com
        
        # Stop existing container
        docker stop mono-repo-$FULL_IMAGE_NAME || true
        docker rm mono-repo-$FULL_IMAGE_NAME || true
        
        # Pull and run new container with all environment variables
        docker pull $ECR_REPOSITORY:latest
        docker run -d --name mono-repo-$FULL_IMAGE_NAME -p 80:$CONTAINER_PORT \
          $(echo "$EC2_ENV_VARS" | sed 's/,/ -e /g' | sed 's/^/-e /') \
          --restart unless-stopped \
          --log-driver=awslogs \
          --log-opt awslogs-group=/aws/ec2/mono-repo-$ENV-$SERVICE \
          --log-opt awslogs-region=$AWS_DEFAULT_REGION \
          --log-opt awslogs-stream=\$(hostname) \
          $ECR_REPOSITORY:latest
        
        # Wait for container to be ready
        sleep 10
        
        # Health check
        for i in {1..30}; do
          if curl -f http://localhost/health > /dev/null 2>&1 || curl -f http://localhost/ > /dev/null 2>&1; then
            echo "Container is healthy"
            exit 0
          fi
          echo "Waiting for container to be ready... (attempt \$i/30)"
          sleep 10
        done
        
        echo "Container failed to become healthy"
        exit 1
        EOF
              
              # Application stop script
              cat > /tmp/codedeploy-$SERVICE/scripts/application_stop.sh << EOF
        #!/bin/bash
        docker stop mono-repo-$FULL_IMAGE_NAME || true
        docker rm mono-repo-$FULL_IMAGE_NAME || true
        EOF
              
              # Validate service script
              cat > /tmp/codedeploy-$SERVICE/scripts/validate_service.sh << 'EOF'
        #!/bin/bash
        sleep 30
        curl -f http://localhost/health || curl -f http://localhost/ || exit 1
        EOF
              
              # Make scripts executable
              chmod +x /tmp/codedeploy-$SERVICE/scripts/*.sh
              
              # Create deployment package
              cd /tmp/codedeploy-$SERVICE
              zip -r /tmp/${FULL_IMAGE_NAME}-deployment.zip .
              cd - > /dev/null
              
              # Upload deployment package to S3
              S3_DEPLOYMENT_KEY="ec2-deployments/$ENV/$SERVICE/$CODEBUILD_BUILD_ID.zip"
              aws s3 cp /tmp/${FULL_IMAGE_NAME}-deployment.zip s3://$DEPLOYMENT_BUCKET/$S3_DEPLOYMENT_KEY
              
              # Trigger CodeDeploy deployment
              APPLICATION_NAME="mono-repo-$ENV-app"
              DEPLOYMENT_GROUP="mono-repo-$ENV-deployment-group"
              
              # Create CodeDeploy application if it doesn't exist
              aws deploy get-application --application-name $APPLICATION_NAME > /dev/null 2>&1 || \
                aws deploy create-application --application-name $APPLICATION_NAME --compute-platform Server
              
              # Create deployment
              DEPLOYMENT_ID=$(aws deploy create-deployment \
                --application-name $APPLICATION_NAME \
                --deployment-group-name $DEPLOYMENT_GROUP \
                --s3-location bucket=$DEPLOYMENT_BUCKET,key=$S3_DEPLOYMENT_KEY,bundleType=zip \
                --query 'deploymentId' --output text)
              
              echo "‚úÖ EC2 deployment initiated: $FULL_IMAGE_NAME"
              echo "üîó Deployment ID: $DEPLOYMENT_ID"
              echo "$SERVICE=http://load-balancer-url" >> /tmp/service_urls
              ;;
              
            *)
              echo "‚ùå Unknown service type: $SERVICE_TYPE"
              ;;
          esac
          
          echo "---"
        done

  post_build:
    commands:
      - echo "üîç Post-deployment validation and notifications..."
      - source /tmp/deployment_status
      
      - |
        if [ "$SKIP_DEPLOYMENT" = "true" ]; then
          echo "‚è≠Ô∏è Skipping post-build - no deployment occurred"
          exit 0
        fi
        
        CHANGED_SERVICES=$(cat /tmp/changed_services)
        ENV=$(cat /tmp/environment)
        
        echo "üìã Deployment Summary:"
        echo "Environment: $ENV"
        echo "Services: $CHANGED_SERVICES"
        echo "Build ID: $CODEBUILD_BUILD_ID"
        
        # Display service URLs if available
        if [ -f "/tmp/service_urls" ]; then
          echo "üîó Service URLs:"
          cat /tmp/service_urls
        fi
        
        # Send notification to Slack (if configured)
        if [ ! -z "$SLACK_WEBHOOK_URL" ]; then
          DEPLOYMENT_SUMMARY="üöÄ *AWS Deployment Completed*\n"
          DEPLOYMENT_SUMMARY="${DEPLOYMENT_SUMMARY}Environment: \`$ENV\`\n"
          DEPLOYMENT_SUMMARY="${DEPLOYMENT_SUMMARY}Services: \`$CHANGED_SERVICES\`\n"
          DEPLOYMENT_SUMMARY="${DEPLOYMENT_SUMMARY}Build ID: \`$CODEBUILD_BUILD_ID\`\n"
          
          if [ -f "/tmp/service_urls" ]; then
            DEPLOYMENT_SUMMARY="${DEPLOYMENT_SUMMARY}\nüìã *Service URLs:*\n"
            while IFS='=' read -r SERVICE URL; do
              if [ ! -z "$URL" ]; then
                DEPLOYMENT_SUMMARY="${DEPLOYMENT_SUMMARY}‚Ä¢ $SERVICE: $URL\n"
              fi
            done < /tmp/service_urls
          fi
          
          curl -X POST -H 'Content-type: application/json' \
            --data "{\"text\": \"$DEPLOYMENT_SUMMARY\"}" \
            $SLACK_WEBHOOK_URL || echo "Failed to send Slack notification"
        fi
        
        echo "‚úÖ AWS deployment process completed successfully!"

artifacts:
  files:
    - '**/*'
  name: mono-repo-build-$CODEBUILD_BUILD_ID
